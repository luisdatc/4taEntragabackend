Hola, te voy a compartir codigo de un proyecto en nodejs usando mongodb como base de datos, express para el servidor. el codiigo es el siguiente: 

//ARCHIVO main.JS

import "dotenv/config";
import express from "express";
import cors from "cors";
import session from "express-session";
import MongoStore from "connect-mongo";
import mongoose from "mongoose";
import path from "path";
import passport from "passport";
import initializePassport from "./config/passport.js";
import cookieParser from "cookie-parser";
import router from "./routes/index.routes.js";
import nodemailer from "nodemailer";
import { __dirname } from "./path.js";
import { addLogger } from "./utils/logger.js";
import swaggerJSDoc from "swagger-jsdoc";
import swaggerUiExpress from "swagger-ui-express";

const whiteList = ["http://127.0.0.1:5173", "http://localhost:5173"];

const corsOptions = {
  origin: function (origin, callback) {
    if (whiteList.indexOf(origin) != -1 || !origin) {
      callback(null, true);
    } else {
      callback(new Error("Acceso Denegado"));
    }
  },
  credentials: true,
};

const app = express();
const PORT = 8080;

//Conexion a la Base de Datos
mongoose
  .connect(process.env.MONGO_URL)
  .then(() => console.log("DB Conectada"))
  .catch(() => console.log("Error en conexion a BDD"));

//MIDDLEWARE
app.use(express.json());

app.use(cors(corsOptions));

app.use(cookieParser(process.env.SIGNED_COOKIE)); //la cookie esta firmada

app.use(
  session({
    store: MongoStore.create({
      mongoUrl: process.env.MONGO_URL,
      mongoOptions: {
        useNewUrlParser: true, //estable la conexxion mediante url
        useUnifiedTopology: true, //para conectarse al controlador de la basse de ddatos y manejo de cluster de manera dinamicca
      },
      ttl: 60, //duracion de la sesion en segundos en la base de datos
    }),
    secret: process.env.SESSION_SECRET,
    resave: /* true */ false, //fuerzo a que se intente a guardar a oesar de no tener modificacion en los datos
    saveUninitialized: /* true */ false, //fuerzo a guardar la sesion a pesar de no tener ningun dato
  })
);
app.use(express.urlencoded({ extended: true }));

initializePassport();
app.use(passport.initialize());
app.use(passport.session());

//verifico si el usuario es administrador o no
/* const auth = (req, res, next) => {
  if (req.session.login === true) {
    next(); // Continuar con la siguiente ejecución
  } else {
    res.redirect("/api/sessions/login");
  }
}; */

app.set("views", path.resolve(__dirname, "./views")); //resuelve rutas absolutas a travez de rutas relativas
app.use("/static", express.static(path.join(__dirname, "/public")));
app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.login === true; // Define una variable local en res.locals
  next();
});

//Routes
app.use("/", router);

const swaggerOptions = {
  definition: {
    openapi: "3.1.0",
    info: {
      title: "Documentacion Api Comic Store",
      description: "Proyecto realizado para curso Backend de Coder House",
    },
  },
  apis: [`${__dirname}/docs/**/*.yaml`], //**indica sub carpeta
};

const specs = swaggerJSDoc(swaggerOptions);

app.use("/apidocs", swaggerUiExpress.serve, swaggerUiExpress.setup(specs));

app.listen(PORT, () => {
  console.log(`Server on port ${PORT}`);
});

//MODELOS 

import { Schema, model } from "mongoose";

const cartSchema = new Schema(
  {
    products: {
      type: [
        {
          id_prod: {
            type: Schema.Types.ObjectId,
            ref: "products",
            required: true,
          },
          quantity: {
            type: Number,
            required: true,
          },
        },
      ],
      default: function () {
        return [];
      },
    },
  },
  { versionKey: false }
);

cartSchema.pre("findOne", function () {
  this.populate("products.id_prod");
});

export const cartModel = model("cart", cartSchema);

import { Schema, model } from "mongoose";
import mongoosePaginate from 'mongoose-paginate-v2';

const productSchema = new Schema(
  {
    title: {
      type: String,
      required: true,
    },
    description: {
      type: String,
      required: true,
    },
    price: {
      type: Number,
      required: true,
    },
    thumbnails: [],
    status: {
      type: Boolean,
      default: true,
    },
    code: {
      type: String,
      required: true,
      unique: true,
    },
    stock: {
      type: Number,
      required: true,
    },
    category: {
      type: String,
      required: true,
    },
  },
  { versionKey: false }
);

productSchema.plugin(mongoosePaginate);

export const productModel = model("products", productSchema);

import { Schema, model } from "mongoose";
import { v4 as uuidv4 } from 'uuid';

const ticketSchema = new Schema(
  {
    code: {
      type: String,
      unique: true,
    },
    purchase_datetime: {
      type: Date,
      default: Date.now,
    },
    amount: {
      type: Number,
      required: true,
    },
    purchaser: {
      type: String,
      required: true,
    },
  },
  { versionKey: false }
);

// Agregamos un pre-save middleware para generar el código automáticamente
ticketSchema.pre("save", function (next) {
  if (!this.code) {
    this.code = uuidv4();
  }
  next();
});

export const ticketModel = model("Ticket", ticketSchema);

import { Schema, model } from "mongoose";
import mongoosePaginate from "mongoose-paginate-v2";
import { cartModel } from "./cart.models.js";
import crypto from "crypto";

const userSchema = new Schema({
  first_name: {
    type: String,
    required: true,
  },
  last_name: {
    type: String,
    required: true,
    index: true,
  },
  age: {
    type: Number,
    required: true,
  },
  email: {
    type: String,
    unique: true,
    required: true,
  },
  password: {
    type: String,
    required: true,
  },
  rol: {
    type: String,
    enum: ["user", "admin", "premium"],
    default: "user",
  },
  cart: {
    type: Schema.Types.ObjectId,
    ref: "carts",
  },
  resetPasswordToken: String,
  resetPasswordExpires: Date,
});

userSchema.methods.generatePasswordReset = function () {
  this.resetPasswordToken = crypto.randomBytes(20).toString("hex");
  this.resetPasswordExpires = Date.now() + 3600000; // 1 hora de expiración
};

/* userSchema.plugin(mongoosePaginate); */

userSchema.pre("save", async function (next) {
  try {
    if (this.isNew || this.isModified("password")) {
      this.generatePasswordReset();
    }

    const newCarrito = await cartModel.create({});
    this.cart = newCarrito._id;
  } catch (error) {
    next(error);
  }
});

export const userModel = model("users", userSchema);

//CONTROLADORES

import { cartModel } from "../models/cart.models.js";
import { productModel } from "../models/products.models.js";
import { ticketModel } from "../models/ticket.models.js";
import EError from "../services/errors/enum.js";
import {
  generateCartError,
  generateDatabaseError,

} from "../services/errors/info.js";
import CustomError from "../services/errors/CustomError.js";

export const getCarrito = async (req, res) => {
  const { limit } = req.query;
  try {
    const carts = await cartModel.find().limit(limit);
    res.status(200).send({ respuesta: "ok", mensaje: carts });
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en consultar carritos: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const getCarritoById = async (req, res) => {
  const { id } = req.params;

  try {
    const cart = await cartModel.findById(id);

    if (cart) {
      res.status(200).send({ respuesta: "OK", mensaje: cart });
    } else {
      res.status(404).send({
        error: CustomError.createError({
          name: "NotFoundError",
          message: "Carrito no encontrado",
          code: EError.NOT_FOUND_ERROR,
        }),
      });
    }
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en consultar el carrito: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const postCarrito = async (req, res) => {
  try {
    const cart = await cartModel.create({});
    res.status(200).send({ respuesta: "OK", mensaje: cart });
  } catch (error) {
    res.status(400).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en crear el carrito: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const postCarritoByProductId = async (req, res) => {
  const { cid, pid } = req.params;
  const { quantity } = req.body;

  try {
    const cart = await cartModel.findById(cid);

    if (!cart) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateCartError(cid),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    const product = await productModel.findById(pid);

    if (!product) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateProductNotFoundError(pid),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    const indice = cart.products.findIndex((prod) => prod.id_prod === pid);

    if (indice !== -1) {
      cart.products[indice].quantity = quantity;
    } else {
      cart.products.push({ id_prod: pid, quantity: quantity });
    }

    const response = await cartModel.findByIdAndUpdate(cid, cart);

    res.status(200).send({
      respuesta: "OK",
      mensaje: "Producto agregado al carrito",
      carrito: response, // Opcional: puedes enviar el carrito actualizado como respuesta
    });
  } catch (error) {
    console.error(error);

    if (error instanceof CustomError) {
      res.status(404).send({
        error: error,
      });
    } else {
      res.status(500).send({
        error: CustomError.createError({
          name: "ServerError",
          message: `Ha ocurrido un error en el servidor: ${error.message}`,
          code: EError.INTERNAL_SERVER_ERROR,
          cause: error,
        }),
      });
    }
  }
};

export const deleteById = async (req, res) => {
  const { id } = req.params;

  try {
    const cart = await cartModel.findById(id);

    if (!cart) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateCartError(id),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    cart.products = [];
    await cart.save();

    res.status(200).send({
      respuesta: "OK",
      mensaje: "Productos eliminados del carrito",
      carrito: cart,
    });
  } catch (error) {
    console.error(error);

    if (error instanceof CustomError) {
      res.status(404).send({
        error: error,
      });
    } else {
      res.status(500).send({
        error: CustomError.createError({
          name: "ServerError",
          message: `Ha ocurrido un error en el servidor: ${error.message}`,
          code: EError.INTERNAL_SERVER_ERROR,
          cause: error,
        }),
      });
    }
  }
};

export const putCarritoByProducId = async (req, res) => {
  try {
    const { cid, pid } = req.params;
    const { quantity } = req.body;

    const cart = await cartModel.findById(cid);

    if (!cart) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateCartError(cid),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    const product = await productModel.findById(pid);

    if (!product) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateProductNotFoundError(pid),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    const indice = cart.products.findIndex(
      (prod) => prod.id_prod._id.toString() === pid
    );

    if (indice !== -1) {
      cart.products[indice].quantity = quantity;
    } else {
      cart.products.push({ id_prod: pid, quantity: quantity });
    }

    await cart.save();

    res.status(200).send({
      respuesta: "OK",
      mensaje: "Carrito actualizado",
      carrito: cart,
    });
  } catch (error) {
    console.error(error);

    if (error instanceof CustomError) {
      res.status(404).send({
        error: error,
      });
    } else {
      res.status(500).send({
        error: CustomError.createError({
          name: "ServerError",
          message: `Ha ocurrido un error en el servidor: ${error.message}`,
          code: EError.INTERNAL_SERVER_ERROR,
          cause: error,
        }),
      });
    }
  }
};

export const deleteProductById = async (req, res) => {
  const { cid, pid } = req.params;

  try {
    const cart = await cartModel.findById(cid);
    if (!cart) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateCartError(cid),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    const product = await productModel.findById(pid);
    if (!product) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateProductNotFoundError(pid),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    const index = cart.products.findIndex(
      (prod) => prod.id_prod._id.toString() === pid
    );
    if (index !== -1) {
      cart.products.splice(index, 1);
    } else {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateProductNotFoundError(pid),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    await cart.save();

    res.status(200).send({ respuesta: "OK", mensaje: "Product removed" });
  } catch (error) {
    console.error(error);

    if (error instanceof CustomError) {
      res.status(404).send({
        error: error,
      });
    } else {
      res.status(500).send({
        error: CustomError.createError({
          name: "ServerError",
          message: `Ha ocurrido un error en el servidor: ${error.message}`,
          code: EError.INTERNAL_SERVER_ERROR,
          cause: error,
        }),
      });
    }
  }
};

export const putCarrito = async (req, res) => {
  const { cid } = req.params;
  const productsArray = req.body.products;

  try {
    const cart = await cartModel.findById(cid);

    if (!cart) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateDatabaseError(`Carrito con ID ${cid} no encontrado`),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    if (!Array.isArray(productsArray)) {
      throw CustomError.createError({
        name: "BadRequestError",
        message: generateDatabaseError(
          "Los productos deben estar en un arreglo"
        ),
        code: EError.BAD_REQUEST_ERROR,
      });
    }

    const updatedProducts = [];

    for (let prod of productsArray) {
      const product = await productModel.findById(prod.id_prod);

      if (!product) {
        throw CustomError.createError({
          name: "NotFoundError",
          message: generateProductNotFoundError(prod.id_prod),
          code: EError.NOT_FOUND_ERROR,
        });
      }

      const existingProductIndex = cart.products.findIndex(
        (cartProduct) => cartProduct.id_prod.toString() === prod.id_prod
      );

      if (existingProductIndex !== -1) {
        cart.products[existingProductIndex].quantity = prod.quantity;
      } else {
        cart.products.push({
          id_prod: prod.id_prod,
          quantity: prod.quantity,
        });
      }

      updatedProducts.push({
        id_prod: prod.id_prod,
        quantity: prod.quantity,
      });
    }

    await cart.save();

    return res.status(200).json({
      respuesta: "OK",
      mensaje: "Carrito actualizado exitosamente",
      productosActualizados: updatedProducts,
    });
  } catch (error) {
    console.error(error);

    if (error instanceof CustomError) {
      res.status(404).json({
        error: error,
      });
    } else {
      res.status(500).json({
        error: CustomError.createError({
          name: "ServerError",
          message: `Ha ocurrido un error en el servidor: ${error.message}`,
          code: EError.INTERNAL_SERVER_ERROR,
          cause: error,
        }),
      });
    }
  }
};

export const postCompra = async (req, res) => {
  const cartId = req.params.cid;

  try {
    const cart = await cartModel.findById(cartId).populate("items.product");
    if (!cart) {
      throw CustomError.createError({
        name: "NotFoundError",
        message: generateDatabaseError(`Carrito con ID ${cartId} no encontrado`),
        code: EError.NOT_FOUND_ERROR,
      });
    }

    const productsNotProcessed = [];

    for (const item of cart.items) {
      const product = item.product;
      const requestedQuantity = item.quantity;

      if (product.stock >= requestedQuantity) {
        product.stock -= requestedQuantity;
        await product.save();
      } else {
        productsNotProcessed.push(product._id);
      }
    }

    cart.items = cart.items.filter(
      (cartItem) => !productsNotProcessed.includes(cartItem.product._id)
    );
    await cart.save();

    const ticket = new ticketModel({
      amount: cart.total,
      purchaser: cart.userEmail,
    });
    await ticket.save();

    return res.status(200).json({
      message: "Compra finalizada exitosamente",
      productsNotProcessed: productsNotProcessed,
    });
  } catch (error) {
    console.error(error);

    if (error instanceof CustomError) {
      res.status(404).json({
        error: error,
      });
    } else {
      res.status(500).json({
        error: CustomError.createError({
          name: "ServerError",
          message: `Ha ocurrido un error en el servidor: ${error.message}`,
          code: EError.INTERNAL_SERVER_ERROR,
          cause: error,
        }),
      });
    }
  }
};

import { productModel } from "../models/products.models.js";
import EError from "../services/errors/enum.js";
import CustomError from "../services/errors/CustomError.js";

export const getProducts = async (req, res) => {
  const { limit, page, filter, sort } = req.query;

  const pag = page ? page : 1;
  const lim = limit ? limit : 100;
  const ord = sort == "asc" ? 1 : -1;

  try {
    const products = await productModel.paginate(
      { filter: filter },
      { limit: lim, page: pag, sort: { price: ord } }
    );

    if (products.docs.length > 0) {
      return res.status(200).send(products);
    }

    res.status(404).send({
      error: CustomError.createError({
        name: "NotFoundError",
        message: "Productos no encontrados",
        code: EError.NOT_FOUND_ERROR,
      }),
    });
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en consultar productos: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const getProduct = async (req, res) => {
  const { id } = req.params;

  try {
    const product = await productModel.findById(id);

    if (product) {
      return res.status(200).send(product);
    }

    res.status(404).send({
      error: CustomError.createError({
        name: "NotFoundError",
        message: "Producto no encontrado",
        code: EError.NOT_FOUND_ERROR,
      }),
    });
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en consultar producto: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const postProduct = async (req, res) => {
  const { title, description, code, price, stock, category } = req.body;
  const userId = req.user._id; // Obtén el ID del usuario actual desde la sesión
  const userRole = req.user.role;

  try {
    const newProduct = await productModel.create({
      title,
      description,
      code,
      price,
      stock,
      category,
      owner: userRole === "premium" ? userId : "admin", // Asignar el owner según el rol del usuario
    });

    if (newProduct) {
      return res.status(201).send(newProduct);
    }
    res.status(400).send({
      error: CustomError.createError({
        name: "ValidationError",
        message: "Error en crear producto",
        code: EError.VALIDATION_ERROR,
      }),
    });
  } catch (error) {
    if (error.code == 11000) {
      // Código para clave duplicada
      return res.status(400).send({
        error: CustomError.createError({
          name: "ValidationError",
          message: "Producto ya creado con clave duplicada",
          code: EError.VALIDATION_ERROR,
        }),
      });
    }
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en crear producto: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const putProduct = async (req, res) => {
  const { id } = req.params;
  const { title, description, code, price, stock, category } = req.body;

  try {
    const updatedProduct = await productModel.findByIdAndUpdate(id, {
      title,
      description,
      code,
      price,
      stock,
      category,
    });

    if (updatedProduct) {
      return res.status(200).send(updatedProduct);
    }

    res.status(404).send({
      error: CustomError.createError({
        name: "NotFoundError",
        message: "Producto no encontrado",
        code: EError.NOT_FOUND_ERROR,
      }),
    });
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en actualizar el producto: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const deleteProduct = async (req, res) => {
  const { id } = req.params;

  try {
    const deletedProduct = await productModel.findByIdAndDelete(id);

    if (deletedProduct) {
      return res.status(200).send(deletedProduct);
    }

    res.status(404).send({
      error: CustomError.createError({
        name: "NotFoundError",
        message: "Producto no encontrado",
        code: EError.NOT_FOUND_ERROR,
      }),
    });
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en eliminar producto: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

import crypto from "crypto";
import { userModel } from "../models/users.models.js";
import nodemailer from "nodemailer";
import { createHash } from "../utils/bcrypt.js";

export const resetPasswordPost = async (req, res) => {
  const transporter = nodemailer.createTransport({
    service: "gmail",
    host: "smtp.gmail.com",
    port: 465,
    secure: true,
    auth: {
      user: "correomcoc@gmail.com",
      pass: process.env.PASSWORD_EMAIL,
    },
    tls: {
      rejectUnauthorized: false,
    },
  });

  try {
    const { email } = req.body;

    // Buscar al usuario por correo electrónico
    const user = await userModel.findOne({ email });

    if (!user) {
      return res.status(404).send({ message: "Usuario no encontrado" });
    }

    // Generar y guardar token de restablecimiento de contraseña
    const resetToken = crypto.randomBytes(20).toString("hex");
    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = Date.now() + 3600000; // 1 hora de expiración
    await user.save();

    // Enviar correo electrónico con el enlace de restablecimiento
    const resetLink = `http://localhost:5173/reset-password/${resetToken}`;

    const mailOptions = {
      from: "tu_correo@gmail.com", // Reemplaza con tu dirección de correo electrónico
      to: email,
      subject: "Restablecimiento de Contraseña",
      html: `<p>Haz clic en el siguiente enlace para restablecer tu contraseña: <a href="${resetLink}">Restablecer Contraseña</a></p>`,
    };

    await transporter.sendMail(mailOptions);

    res.status(200).json({
      message:
        "Correo electrónico enviado con instrucciones para restablecer la contraseña",
    });
  } catch (error) {
    console.error("Error al solicitar restablecimiento de contraseña:", error);
    res
      .status(500)
      .send({ message: "Error interno del servidor", error: error.message });
  }
};

export const resetPasswordConfirmPost = async (req, res) => {
  try {
    const { token } = req.params;
    const { newPassword } = req.body;

    // Buscar al usuario por el token de restablecimiento de contraseña
    const user = await userModel.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() },
    });

    if (!user) {
      return res.status(404).send({ message: "Token no válido o expirado" });
    }

    // Hash de la nueva contraseña
    const newPasswordHash = createHash(newPassword);

    // Actualizar la contraseña y limpiar los campos de restablecimiento
    user.password = newPasswordHash;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save();

    res.status(200).send({ message: "Contraseña restablecida con éxito" });
  } catch (error) {
    console.error("Error al restablecer la contraseña:", error);
    res
      .status(500)
      .send({ message: "Error interno del servidor", error: error.message });
  }
};

import { generateToken, authToken } from "../utils/jwt.js";

export const postLogin = async (req, res) => {
  try {
    if (!req.user) {
      return res.status(401).send({ mensaje: "Usuario invalido" });
    }

    const token = generateToken(req.user);

    res.status(200).send({ token });
  } catch (error) {
    res.status(500).send({ mensaje: `Error al iniciar sesion ${error}` });
  }
};

export const postRegister = async (req, res) => {
  try {
    if (!req.user) {
      return res.status(400).send({ mensaje: "Usuario ya existente" });
    }

    res.status(200).send({ mensaje: "Usuario registrado" });
  } catch (error) {
    res.status(500).send({ mensaje: `Error al registrar usuario ${error}` });
  }
};

export const getGithub = async (req, res) => {
  res.status(200).send({ mensaje: "Usuario registrado" });
};

export const getGihubCallback = async (req, res) => {
  req.session.user = req.user;
  res.status(200).send({ mensaje: "Usuario logueado" });
};

export const getLogout = async (req, res) => {
  res.clearCookie("jwtCookie");
  res.status(200).send({ resultado: "Usuario deslogueado" });
};

import { cartModel } from "../models/cart.models";
import { ticketModel } from "../models/ticket.models";
import { productModel } from "../models/products.models";

export const postCompra = async (req, res) => {
  const cartId = req.params.cid;

  try {
    const cart = await cartModel.findById(cartId).populate("items.product");
    if (!cart) {
      return res.status(404).json({ message: "Carrito no encontrado" });
    }

    const productsNotProcessed = []; // aca se almacenan los productos que no se pudieron procesar

    for (const item of cart.items) {
      const product = item.product;
      const requestedQuantity = item.quantity;

      if (product.stock >= requestedQuantity) {
        // El producto tiene suficiente stock, restarlo
        product.stock -= requestedQuantity;
        await product.save();
      } else {
        // si el producto no tiene suficiente stock se almacenan en los no procesados
        productsNotProcessed.push(product._id);
      }
    }

    // se actualiza el carrito con los productos no procesados
    cart.items = cart.items.filter(
      (cartItem) => !productsNotProcessed.includes(cartItem.product._id)
    );
    await cart.save();

    // se crea un ticket con los datos de la compra
    const ticket = new ticketModel({
      amount: cart.total, // Supongo que el carrito tiene un campo total
      purchaser: cart.userEmail, // O donde se almacena el correo del usuario
    });
    await ticket.save();

    return res.status(200).json({
      message: "Compra finalizada exitosamente",
      productsNotProcessed: productsNotProcessed,
    });
  } catch (error) {
    console.error(error);
    return res.status(500).json({ message: "Error al procesar la compra" });
  }
};

import { userModel } from "../models/users.models.js";
import CustomError from "../services/errors/CustomError.js";
import EError from "../services/errors/enum.js";
import { generateUserError } from "../services/errors/info.js";
import nodemailer from "nodemailer";

export const getUsers = async (req, res) => {
  try {
    const user = await userModel.find();

    if (user) {
      return res.status(200).send(user);
    }
    res.status(404).send(generateUserError({}));
  } catch (error) {
    res.status(500).send({
      error: generateDatabaseError(`Error en consultar el usuario ${error}`),
    });
  }
};

export const getUserbyId = async (req, res) => {
  const { id } = req.params;

  try {
    const userId = await userModel.findById(id);

    if (userId) {
      return res.status(200).send(userId);
    }
    res.status(404).send({
      error: CustomError.createError({
        name: "NotFoundError",
        message: "Usuario no encontrado",
        code: EError.NOT_FOUND_ERROR,
      }),
    });
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en consultar usuario: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const putUser = async (req, res) => {
  const { id } = req.params;
  const { first_name, last_name, age, email, password } = req.body;

  try {
    const updatedUser = await userModel.findByIdAndUpdate(id, {
      first_name,
      last_name,
      age,
      email,
      password,
    });

    if (updatedUser) {
      return res.status(200).send(updatedUser);
    }
    res.status(404).send({
      error: CustomError.createError({
        name: "NotFoundError",
        message: "Usuario no encontrado",
        code: EError.NOT_FOUND_ERROR,
      }),
    });
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en actualizar el usuario: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

export const deleteUser = async (req, res) => {
  const { id } = req.params;
  try {
    const deletedUser = await userModel.findByIdAndDelete(id);
    if (deletedUser) {
      res.status(200).send({ user: deletedUser });
    } else {
      res.status(404).send({
        error: CustomError.createError({
          name: "NotFoundError",
          message: "Usuario no encontrado",
          code: EError.NOT_FOUND_ERROR,
        }),
      });
    }
  } catch (error) {
    res.status(500).send({
      error: CustomError.createError({
        name: "DatabaseError",
        message: `Error en eliminar usuario: ${error.message}`,
        code: EError.DATABASE_ERROR,
        cause: error,
      }),
    });
  }
};

const transporter = nodemailer.createTransport({
  service: "gmail",
  host: "smtp.gmail.com",
  port: 465,
  secure: true,
  auth: {
    user: "correomcoc@gmail.com",
    pass: process.env.PASSWORD_EMAIL,
  },
  tls: {
    rejectUnauthorized: false,
  },
});

export const sendPasswordResetEmail = async (userEmail) => {
  const resetToken = crypto.randomBytes(20).toString("hex");
  // Guarda resetToken en la base de datos junto con el correo del usuario y una marca de tiempo

  const resetLink = `http://localhost:5173/reset-password/${resetToken}`;

  const mailOptions = {
    from: "correomcoc@gmail.com",
    to: userEmail,
    subject: "Restablecimiento de Contraseña",
    html: `<p>Haz clic en el siguiente enlace para restablecer tu contraseña: <a href="${resetLink}">Restablecer Contraseña</a></p>`,
  };

  await transporter.sendMail(mailOptions);
};

export const getUserByEmail = async (email) => {
  return userModel.findOne({ email });
};

//RUTAS

import { Router } from "express";
import {
  getCarrito,
  getCarritoById,
  postCarrito,
  postCarritoByProductId,
  deleteById,
  putCarritoByProducId,
  deleteProductById,
  putCarrito,
  postCompra,
} from "../controllers/carrito.controllers.js";

const cartsRouter = Router();

cartsRouter.get("/", getCarrito);
cartsRouter.post("/", postCarrito);/* esta */

cartsRouter.get("/:cid", getCarritoById);
cartsRouter.put("/:cid", putCarrito);

cartsRouter.delete("/:id", deleteById);

cartsRouter.post("/:cid/products/:pid", postCarritoByProductId);
cartsRouter.delete("/:cid/products/:pid", deleteProductById);
cartsRouter.put("/:cid/products/:pid", putCarritoByProducId);

cartsRouter.post("/:cid/purchase", postCompra);



export default cartsRouter;

import { Router } from "express";
import cartsRouter from "./carrito.routes.js";
import productosRouter from "./products.routes.js";
import sessionRouter from "./session.routes.js";
import userRouter from "./users.routes.js";

import resetPasswordRouter from "./resetPassword.routes.js";
import loggerRouter from "./logger.routes.js";

const router = Router();

//Rutas de la app
router.use("/api/users", userRouter);
router.use("/api/products", productosRouter);
router.use("/api/carts", cartsRouter);
router.use("/api/sessions", sessionRouter);
router.use("/api/logger", loggerRouter);
router.use("/api/reset-password", resetPasswordRouter);
export default router;

import { Router } from "express";
import { addLogger } from "../utils/logger.js";

const loggerRouter = Router();

loggerRouter.use(addLogger);

loggerRouter.get("/fatal", (req, res) => {
  req.logger.fatal("Hola fatal");
  res.send("Hola mundo");
});

loggerRouter.get("/error", (req, res) => {
  req.logger.error("Hola error");
  res.send("Hola mundo");
});

loggerRouter.get("/warning", (req, res) => {
  req.logger.warning("Hola warning");
  res.send("Hola mundo");
});

loggerRouter.get("/info", (req, res) => {
  req.logger.info("Hola info");
  res.send("Hola mundo");
});

loggerRouter.get("/debug", (req, res) => {
  req.logger.debug("Hola debug");
  res.send("Hola mundo");
});

loggerRouter.get("/http", (req, res) => {
  req.logger.http("Hola http");
  res.send("Hola mundo");
});
export default loggerRouter;

import { Router } from "express";
import {
  getProducts,
  getProduct,
  deleteProduct,
  putProduct,
  postProduct,
} from "../controllers/products.controllers.js";
import { authorization, passportError } from "../utils/messageError.js";

const productosRouter = Router();

productosRouter.get("/", getProducts);

productosRouter.get("/:id", getProduct);

productosRouter.put(
  "/:id",
  passportError("jwt"),
  authorization("admin", "premium"),
  putProduct
);

productosRouter.delete(
  "/:id",
  passportError("jwt"),
  authorization("admin", "premium"),
  deleteProduct
);

productosRouter.post(
  "/",
  passportError("jwt"),
  authorization("admin", "premium"),
  postProduct
);

export default productosRouter;

import Router from "express";
import {
  resetPasswordConfirmPost,
  resetPasswordPost,
} from "../controllers/resetPassword.controller.js";

const resetPasswordRouter = Router();

// Ruta para solicitar restablecimiento de contraseña
resetPasswordRouter.post("/", resetPasswordPost);

// Ruta para confirmar el restablecimiento de contraseña
resetPasswordRouter.post("/:token", resetPasswordConfirmPost);

export default resetPasswordRouter;

import { Router } from "express";
import {
  postLogin,
  postRegister,
  getGithub,
  getGihubCallback,
  getLogout,
} from "../controllers/session.controllers.js";
import passport from "passport";
import { passportError, authorization } from "../utils/messageError.js";
import { generateToken } from "../utils/jwt.js";

const sessionRouter = Router();

sessionRouter.post("/login", passport.authenticate("login"), postLogin);

sessionRouter.post(
  "/register",
  passport.authenticate("register"),
  postRegister
);

sessionRouter.get(
  "/github",
  passport.authenticate("github", { scope: ["user: email"] }),
  getGithub
);

sessionRouter.get(
  "/githubCallback",
  passport.authenticate("github"),
  getGihubCallback
);

sessionRouter.get("/logout", getLogout);

sessionRouter.get(
  "/current",
  passportError("jwt"),
  authorization("user"),
  (req, res) => {
    res.send(req.user);
  }
);
/* aca puedo cambiar el user por admin si quiero que la ruta sea solo para administradores */
export default sessionRouter;

import { Router } from "express";
import { postCompra } from "../controllers/ticket.controllers";

const ticketRouter = Router();

ticketRouter.post("/:cid/purchase", postCompra);

export default ticketRouter;

import { Router } from "express";
import {
  getUsers,
  getUserbyId,
  putUser,
  deleteUser,
} from "../controllers/users.controllers.js";

import { authorization, passportError } from "../utils/messageError.js";

const userRouter = Router();

userRouter.get("/", passportError("jwt"), authorization("admin"), getUsers);

userRouter.get(
  "/:id",
  passportError("jwt"),
  authorization("admin"),
  getUserbyId
);

userRouter.put("/:id", passportError("jwt"), authorization("admin"), putUser);

userRouter.delete(
  "/:id",
  passportError("jwt"),
  authorization("admin"),
  deleteUser
);

export default userRouter;




1)Modificar el modelo de User para que cuente con una nueva propiedad “documents” el cual será un array que contenga los objetos con las siguientes propiedades
name: String (Nombre del documento).
reference: String (link al documento).
No es necesario crear un nuevo modelo de Mongoose para éste.

2)Además, agregar una propiedad al usuario llamada “last_connection”, la cual deberá modificarse cada vez que el usuario realice un proceso de login y logout. 

3)Crear un endpoint en el router de usuarios api/users/:uid/documents con el método POST que permita subir uno o múltiples archivos. Utilizar el middleware de Multer para poder recibir los documentos que se carguen.

4)El middleware de multer deberá estar modificado para que pueda guardar en diferentes carpetas los diferentes archivos que se suban.
Si se sube una imagen de perfil, deberá guardarlo en una carpeta profiles, en caso de recibir la imagen de un producto, deberá guardarlo en una carpeta products, mientras que ahora al cargar un documento, multer los guardará en una carpeta documents.
